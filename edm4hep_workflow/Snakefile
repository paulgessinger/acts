import re
import functools
import dataclasses

configfile: "snakemake_config.yml"


finding_plots = expand("trackeff_vs_{q}", q=["eta", "pT", "phi"])\
            + ["nHoles_vs_eta", "nMeasurements_vs_eta", "nOutliers_vs_eta"]

params = ["d0", "z0", "qop", "phi", "theta", "t"]

fitting_plots = expand("reswidth_{q}_vs_eta", q=params)


config_file = "config.toml"

particle_gun_samples = []\
  + expand("pg_mu_pt{pt}", pt=[1, 10, 100])\
  + expand("pg_el_pt{pt}", pt=[1, 10])\
  + expand("pg_pi_pt{pt}", pt=[1, 10])\
  + expand("pg_g_pt{pt}", pt=[1, 10])\
  + expand("pg_k_pt{pt}", pt=[1, 10])

madgraph_samples = ["mg_ttbar", "mg_dihiggs"]

@dataclasses.dataclass
class Sample:
  prefix: str|None
  sample: str
  pileup: int|None

  @property
  def full_name(self) -> str:
    name = ""
    if self.prefix is not None:
      name += self.prefix
    name += self.sample
    if self.pileup is not None:
      name += f"_pu{self.pileup}"
    return name

  @property
  def hs_only_name(self) -> str:
    name = ""
    if self.prefix is not None:
      name += self.prefix
    name += self.sample
    return name

def parse_madgraph_sample(sample: str) -> Sample:
  m = re.match(r"(mg_|pg_)?([a-z]+)(?:_pu(\d+))?", sample)
  if m is None:
    raise ValueError(f"Cannot parse sample name for madgraph gen {sample}")
  prefix, act_sample, pileup = m.groups()

  return Sample(prefix=prefix, sample=act_sample, pileup=int(pileup) if pileup is not None else None)


gen_samples = particle_gun_samples + madgraph_samples
samples = particle_gun_samples + expand("{sample}_pu{pu}", sample=madgraph_samples, pu=[0, 10])

sample_name_map = {
    "ttbar": "MadGraph ttbar",
    "dihiggs": "MadGraph di-Higgs",
}

event_counts = {
    "ttbar": 100,
    "dihiggs": 100, 
}

def hstr(s: str, bits: int = 32) -> int:
    import hashlib

    def stable_hash_bits(data: bytes, bits: int) -> int:
        digest = hashlib.sha256(data).digest()
        nbytes = (bits + 7) // 8
        val = int.from_bytes(digest[:nbytes], "little")
        return val & ((1 << bits) - 1)

    # deterministic per string across runs
    return stable_hash_bits(s.encode("utf-8"), bits)

def combine_hashes(*hashes: int, bits: int = 32) -> int:
    """
    Combine multiple integer hashes into a single hash
    of the given bit width (e.g. 32 or 64 bits).
    """
    if bits <= 0 or bits > 128:
        raise ValueError("bits must be between 1 and 128")

    mask = (1 << bits) - 1
    mix_const = {
        32: 0x9e3779b9,
        64: 0x9e3779b97f4a7c15,
    }.get(bits, (1 << (bits - 1)) + (1 << (bits - 3)))  # reasonable fallback

    h = 0
    for x in hashes:
        x &= mask
        h ^= (x + mix_const + ((h << 6) & mask) + (h >> 2)) & mask
    return h & mask

def get_events_single_particles(particle: str) -> int:
    if particle == "mu":
        return 100000
    return 10000

def get_events_madgraph(sample: str, generate: bool) -> int:
    # Never generate less than 2000 events to avoid pythia8 issues
    if generate:
      return max(2000, event_counts[sample])
    else:
      return event_counts[sample]

def get_events_gen(wildcards):
    print("get events:", *[f"{k}={v}" for k,v in wildcards.items()])
    if hasattr(wildcards, "particle"):
        return get_events_single_particles(wildcards.particle)

    if hasattr(wildcards, "sample"):
        sample = wildcards.sample
        parsed = parse_madgraph_sample(sample)
        return get_events_madgraph(parsed.sample, generate=True)

    raise ValueError("Cannot determine event count")

def get_events(wildcards):
    print("get_events non gen", *[f"{k}={v}" for k,v in wildcards.items()])
    sample = wildcards.sample

    if sample.startswith("pg_"):
        m = re.match(r"pg_([a-z]+)_pt(\d+)", sample)
        if m is None:
            raise ValueError("Cannot parse particle gun sample name")
        particle = m.group(1)
        return get_events_single_particles(particle)
    elif sample.startswith("mg_"):
        parsed = parse_madgraph_sample(sample)
        print(sample, parsed)
        return get_events_madgraph(parsed.sample, generate=False)
    else:
      raise ValueError("Cannot determine sample type for event count")


def get_events_pileup(wildcards):
    print("get_events_pileup", *[f"{k}={v}" for k,v in wildcards.items()])
    import math

    def poisson_percentile(N, L):
        """Calculate N-th percentile of Poisson distribution"""
        target = N / 100

        # Start with k=0
        k = 0
        pmf = math.exp(-L)  # P(X = 0) = e^(-λ)
        cumulative = pmf

        while cumulative < target:
            k += 1
            # Use recurrence: P(X = k) = P(X = k-1) * λ / k
            pmf *= L / k
            cumulative += pmf

        return k

    # We need to figure out what the original sample name is!
    if wildcards.sample.startswith("pg_"):
        m = re.match(r"pg_([a-z]+)_pt(\d+)", wildcards.sample)
        if m is None:
            raise ValueError("Cannot parse particle gun sample name")
        particle = m.group(1)
        events = get_events_single_particles(particle)
    elif wildcards.sample.startswith("mg_"):
        parsed = parse_madgraph_sample(wildcards.sample)
        print(wildcards.sample, parsed)

        events = get_events_madgraph(parsed.sample, generate=True)
    else:
        raise ValueError("Cannot determine sample type for pileup event count")

    perc = 66
    multiplier = poisson_percentile(perc, int(wildcards.pileup))
    print(f"{perc}% percentile for {wildcards.pileup} is {multiplier}, so generating {events*multiplier} soft QCD events")

    return events*multiplier

quantities=["eta", "pT", "phi", "prodR"]
reco_diag_plots = expand("reco/{{sample}}/plots/finding/{{sample}}_{key}_vs_{qty}."+config['format'], qty=quantities, key="trackeff")\
                 +expand("reco/{{sample}}/plots/finding/{{sample}}_{key}_vs_{qty}."+config['format'], qty=["eta", "pT"], key=["nStates", "nMeasurements", "nHoles", "nOutliers", "nSharedHits"])\
                 +expand("reco/{{sample}}/plots/pulls/width/{{sample}}_pullwidth_{param}_vs_{qty}."+config['format'], qty=["eta", "pT"], param=params)\
                 +expand("reco/{{sample}}/plots/pulls/mean/{{sample}}_pullmean_{param}_vs_{qty}."+config['format'], qty=["eta", "pT"], param=params)


single_particles = ["mu", "pi", "el"]

rule all:
  input:
    expand("gen/{sample}/{sample}.{ext}", sample=gen_samples, ext=["hepmc3.zst", "pdf"]),
    expand("gen/smeared/{sample}/{sample}.{ext}", sample=samples, ext=["hepmc3.zst", "pdf"]),
    expand("sim/{sample}.edm4hep.root", sample=samples),
    # expand("digi/{sample}.edm4hep.root", sample=samples),
    expand("reco/{sample}/{sample}.edm4hep.root", sample=samples),
    # # Single muon plots
    # expand("reco/pg_{ptcl}/pg_{ptcl}_efficiency."+config["format"], ptcl=single_particles),
    # expand("reco/pg_{ptcl}/pg_{ptcl}_{mtr}."+config["format"], mtr=["pullwidth", "pullmean"], ptcl=single_particles),
    # expand("reco/pg_{ptcl}/pg_{ptcl}_res_{qty}."+config["format"], qty=["d0", "z0", "phi", "theta", "qop", "t"], ptcl=single_particles),
    # # expand("reco/{sample}/{sample}_eff_vs_eta."+config["format"], sample=particle_gun_samples),
    # expand(reco_diag_plots, sample=samples),
    

def pg_gen_inputs(wildcards):
    return sum([
        expand("gen/smeared/{sample}/{sample}.hepmc3.zst", sample=particle_gun_samples),
        expand("gen/smeared/{sample}/{sample}.pdf", sample=particle_gun_samples),
        expand("gen/{sample}/{sample}.hepmc3.zst", sample=particle_gun_samples),
        expand("gen/{sample}/{sample}.pdf", sample=particle_gun_samples),
    ], [])

rule pg_gen:
  input:
    pg_gen_inputs,

def mg_gen_inputs(wildcards):
    samples = []
    exts = ["hepmc3.zst", "pdf"]

    samples += expand(
        "gen/smeared/{sample}_pu{pileup}/{sample}_pu{pileup}.{ext}",
        sample=madgraph_samples, pileup=[10], ext=exts,
    )

    samples += expand(
        "gen/{smeared}{sample}/{sample}.{ext}",
        sample=madgraph_samples, ext=exts, smeared=["smeared/", ""]
    )

    return samples

rule mg_gen:
  input:
    mg_gen_inputs,

rule gen:
  input:
    mg_gen_inputs,
    pg_gen_inputs,


rule madgraph_init:
  output:
    update("samples/mg_{sample}.tar.gz")
  input:
    "samples/{sample}.toml"
  # largely single thread but compilation goes up
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml -vv madgraph init {input} {output}"


def mg_sample_inputs(wildcards):
  # parse "true" sample name and pileup (ignore pileup)
  sample = wildcards.sample
  # print(sample)
  parsed = parse_madgraph_sample(sample)
  res = [
    f"samples/{parsed.sample}.toml",
    f"samples/mg_{parsed.sample}.tar.gz"
  ]
  # print("mg sample inputs:", res)
  return res


rule madgraph_gen:
  input:
    mg_sample_inputs,
  output:
    update("gen/mg_{sample}/mg_{sample}.hepmc3.zst"),
    update("gen/mg_{sample}/mg_{sample}.hepmc3.zst.json"),
  params:
    events=get_events_gen,
    seed=lambda w: combine_hashes(config["seed"], hstr(w.sample), hstr("madgraph_gen"), bits=29)
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml -vv madgraph generate {input} --events {params.events} {output[0]} --seed {params.seed}"

rule particle_gun:
  output:
    "gen/pg_{sample}/pg_{particle, [a-z]+}_pt{pt,\\d+}.hepmc3.zst",
    "gen/pg_{sample}/pg_{particle, [a-z]+}_pt{pt,\\d+}.hepmc3.zst.json",
  params:
    events=get_events_gen,
    seed=lambda w: combine_hashes(config["seed"], hstr(w.sample), hstr("particle_gun")),
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml particle-gun --jobs {threads} {output[0]} --type {wildcards.particle} --pt {wildcards.pt} --events {params.events} --seed {params.seed}"

rule hepmc_plots:
  input:
    "gen/{whatever}.hepmc3.zst",
  output:
    "gen/{whatever}.pdf"
  threads: 1
  shell:
    "./with_env.sh colliderml plot hepmc {input} --output {output} --max-events 1000"


rule pileup_gen:
  output:
    "gen/pu_{sample}_pu{pileup}.hepmc3.zst",
    "gen/pu_{sample}_pu{pileup}.hepmc3.zst.json",
  input:
    "samples/soft_qcd.toml"
  params:
    events=get_events_pileup,
    seed=lambda w: combine_hashes(config["seed"], hstr(w.sample), hstr("pileup_gen")),
  shell:
    "./with_env.sh colliderml -vv pythia8 {input} {output[0]} --events {params.events} --seed {params.seed}"

def hepmc_merge_input(wildcards):
  sample = wildcards.sample

  print("hemmc merge input for sample:", sample)
  parsed = parse_madgraph_sample(sample)

  inputs = {"hs": f"gen/{parsed.hs_only_name}/{parsed.hs_only_name}.hepmc3.zst", "pu": []}

  if parsed.pileup is not None and parsed.pileup != 0:
    inputs["pu"] = f"gen/pu_{parsed.hs_only_name}_pu{parsed.pileup}.hepmc3.zst"

  return inputs

def parse_pileup(wildcards):
  m = re.match(r".*_pu(\d+)", wildcards.sample)
  if m is None:
    return 0
  return int(m.group(1))

rule hepmc_merge_smear:
  input:
    unpack(hepmc_merge_input),
    config="pileup.toml",
  output:
    "gen/smeared/{sample}/{sample}.hepmc3.zst",
    "gen/smeared/{sample}/{sample}.hepmc3.zst.json",
  params:
    seed=lambda w: combine_hashes(config["seed"], hstr(w.sample), hstr("hepmc_smear")),
    npileup=lambda w: f"--npileup={parse_pileup(w)}" if parse_pileup(w) > 0 else "",
    pileup=lambda w: "--pileup" if parse_pileup(w) > 0 else "",
    events=get_events_gen,
  shell:
    "./with_env.sh colliderml -vv hepmc merge --hard-scatter {input.hs} {params.pileup} {input.pu} {params.npileup} --config {input.config} {output[0]} --seed {params.seed} --max-events {params.events}"

rule ddsim_sim:
  input:
    "gen/smeared/{sample}/{sample}.hepmc3.zst",
    "gen/smeared/{sample}/{sample}.hepmc3.zst.json",
    config_file,
  output:
    protected("sim/{sample}.edm4hep.root")
  params:
    seed=lambda w: combine_hashes(config["seed"], hstr(w.sample), hstr("ddsim_sim")),
    events=get_events,
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml -vv simulation {input[0]} --output {output[0]} --processes 1 --threads {threads} --config {input[2]} --events {params.events}"

rule sim_pu:
  input:
    "gen/smeared/{sample}_pu{pileup}.hepmc3.zst",
    "gen/smeared/{sample}_pu{pileup}.hepmc3.zst.json",
    config_file,
  output:
    "sim/{sample}_pu{pileup}.edm4hep.root"
  params:
    seed=lambda w: combine_hashes(config["seed"], hstr(w.sample), hstr("sim_pu")),
  threads: workflow.cores/8
  shell:
    "./with_env.sh colliderml -vv simulation {input[0]} --output {output[0]} --processes {threads} --threads 8 --config {input[2]}"

rule digi:
  input:
    sim="sim/{sample}.edm4hep.root",
    config=config_file,
  output:
    "digi/{sample}.edm4hep.root"
  params:
    seed=lambda w: combine_hashes(config["seed"], hstr(w.sample), hstr("digi")),
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml digitization {input.sim} {output} --jobs {threads} --config {input.config}"

rule reco:
  input:
    digi="digi/{sample}.edm4hep.root",
    config=config_file,
  output:
    reco="reco/{sample}/{sample}.edm4hep.root",
    diag=["reco/{sample}/performance_finding_ckf.root", "reco/{sample}/performance_fitting_ckf.root"],
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml reconstruction {input.digi} {output.reco} --jobs {threads} --loglevel INFO --config {input.config}"


params=["d0", "z0", "phi", "theta", "qop", "t"]

rule comparison_plots:
  pathvars:
    ptcl="",
  output:
    finding=expand("reco/pg_<ptcl>/pg_<ptcl>_efficiency.{format}", format=config['format']),
    fitting=expand("reco/pg_<ptcl>/pg_<ptcl>_{mtr}.{format}", mtr=["pullwidth", "pullmean"], format=config['format'])\
           +expand("reco/pg_<ptcl>/pg_<ptcl>_res_{qty}.{format}", qty=params, format=config['format']),
  threads: 1
  run:
    shell("./with_env.sh colliderml plot reco comparison-finding {input.finding} {params.labels} --output {output.finding} --title '{params.title}'")
    shell("./with_env.sh colliderml plot reco comparison-fitting {input.fitting} {params.labels} --output-base reco/pg_{params.particle}/pg_{params.particle}.{params.format} --title '{params.title}'")

use rule comparison_plots as single_muon_plots with:
  pathvars:
    ptcl="mu",
  input:
    finding=expand("reco/pg_<ptcl>_pt{pt}/performance_finding_ckf.root", pt=[1,10, 100]),
    fitting=expand("reco/pg_<ptcl>_pt{pt}/performance_fitting_ckf.root", pt=[1,10, 100]),
  params:
    labels=expand("--label='{pt} GeV'", pt=[1,10,100]),
    format=config['format'],
    title="Single Muons",
    particle="mu",

use rule comparison_plots as single_pion_plots with:
  pathvars:
    ptcl="pi",
  input:
    finding=expand("reco/pg_<ptcl>_pt{pt}/performance_finding_ckf.root", pt=[1,10]),
    fitting=expand("reco/pg_<ptcl>_pt{pt}/performance_fitting_ckf.root", pt=[1,10]),
  params:
    labels=expand("--label='{pt} GeV'", pt=[1,10]),
    format=config['format'],
    title="Single Pions",
    particle="pi",

use rule comparison_plots as single_electron_plots with:
  pathvars:
    ptcl="el",
  input:
    finding=expand("reco/pg_<ptcl>_pt{pt}/performance_finding_ckf.root", pt=[1,10]),
    fitting=expand("reco/pg_<ptcl>_pt{pt}/performance_fitting_ckf.root", pt=[1,10]),
  params:
    labels=expand("--label='{pt} GeV'", pt=[1,10]),
    format=config['format'],
    title="Single Electrons",
    particle="el",


def get_reco_diag_labels(wildcards):
    sample = wildcards.sample
    
    if sample.startswith("pg_"):
        m = re.match(r"pg_([a-z]+)_pt(\d+)", sample)
        if m is None:
            raise ValueError("Cannot parse particle gun sample name")
        particle, pt = m.groups()
        return f"--label='{pt} GeV'"
  
    if sample.startswith("mg_"):
        m = re.match(r"mg_([a-z]+)", sample)
        if m is None:
            raise ValueError("Cannot parse madgraph sample name")
        act_sample = m.group(1)

        friendly_name = sample_name_map.get(act_sample, None)
        return f"--label='{friendly_name}'" if friendly_name is not None else ""

    raise ValueError("Cannot determine labels for reco diag plots")

def get_reco_diag_title(wildcards):
    sample = wildcards.sample 
    print("get reco diag title:", sample)
    
    if sample.startswith("pg_"):
        m = re.match(r"pg_([a-z]+)_pt(\d+)", sample)
        if m is None:
            raise ValueError("Cannot parse particle gun sample name")
        particle, pt = m.groups()

        particle_names = {
            "mu": "Single Muons",
            "el": "Single Electrons",
            "pi": "Single Pions",
            "k": "Single Kaons",
            "g": "Single Photons",
        }

        return f"{particle_names[particle]}, $p_T=${pt} GeV"

    if sample.startswith("mg_"):
        m = re.match(r"mg_([a-z]+)", sample)
        if m is None:
            raise ValueError("Cannot parse madgraph sample name")
        act_sample = m.group(1)
        return sample_name_map.get(act_sample, act_sample)

    raise ValueError("Cannot determine title for reco diag plots")


rule reco_diag_plots:
  input:
    fitting_output="reco/{sample}/performance_fitting_ckf.root",
    script="src/colliderml/cli/plot.py",
  output:
    update(reco_diag_plots),
  threads: 1
  params:
    # labels=expand("--label='{sample}'", pt=wildcards.sample),
    labels=get_reco_diag_labels,
    format=config['format'],
    title=get_reco_diag_title,
  shell:
    "./with_env.sh colliderml plot reco diagnostics {input.fitting_output} {params.labels} --output-base reco/{wildcards.sample}/plots/{wildcards.sample}.{params.format} --title '{params.title}'"

  # shell:
  #   "./with_env.sh colliderml plot reco comparison_finding {input} {params.labels} --output {output} --title 'single muons'"

# rule reco_plots:
#   input:
#     "reco/performance_finding_ckf_{sample}.root",
#     "reco/performance_fitting_ckf_{sample}.root"
#   output:
#     [f"reco/plots/{{sample}}/{plot}.pdf" for plot in finding_plots+fitting_plots],
#     "reco/plots/{sample}/plots_{sample}.pdf"
#   params:
#     finding_plots = ','.join(finding_plots),
#     fitting_plots = ','.join(fitting_plots)
#   threads: 1
#   shell:
    # "./with_env.sh colliderml plot reco {input} reco/plots/{wildcards.sample} --finding-plots {params.finding_plots} --fitting-plots {params.fitting_plots} --label {wildcards.sample}"
    # "./with_env.sh colliderml plot reco {input} "
