import re

finding_plots = expand("trackeff_vs_{q}", q=["eta", "pT", "phi"])\
            + ["nHoles_vs_eta", "nMeasurements_vs_eta", "nOutliers_vs_eta"]

fitting_plots = expand("reswidth_{q}_vs_eta", q=["d0", "z0", "qop", "phi", "theta", "t"])


config_file = "config.toml"

samples = \
    expand("pg_mu_pt{pt}", pt=[1, 10, 100])\
  + expand("pg_el_pt{pt}", pt=[1, 10])\
  + expand("pg_pi_pt{pt}", pt=[1, 10, 100])\
  + ["mg_ttbar", "mg_dihiggs"]

event_counts = {
    "ttbar": 1000,
    "dihiggs": 2000, # don't go too low otherwise pythia8 fails
    "soft_qcd": 1000,
}

def get_events_single_particles(particle: str) -> int:
    return 10000

def get_events_madgraph(sample: str) -> int:
    return event_counts[sample]

def get_events(wildcards):
    print("get events:", wildcards)
    if hasattr(wildcards, "sample"):
        sample = wildcards.sample
        return get_events_madgraph(sample)

    if hasattr(wildcards, "particle"):
        return get_events_single_particles(wildcards.particle)

    raise ValueError("Cannot determine event count")

def get_events_pileup(wildcards):
    import math

    def poisson_percentile(N, L):
        """Calculate N-th percentile of Poisson distribution"""
        target = N / 100
        
        # Start with k=0
        k = 0
        pmf = math.exp(-L)  # P(X = 0) = e^(-λ)
        cumulative = pmf
        
        while cumulative < target:
            k += 1
            # Use recurrence: P(X = k) = P(X = k-1) * λ / k
            pmf *= L / k
            cumulative += pmf
        
        return k

    # We need to figure out what the original sample name is!
    if wildcards.sample.startswith("pg_"):
        m = re.match(r"pg_([a-z]+)_pt(\d+)", wildcards.sample)
        if m is None: 
            raise ValueError("Cannot parse particle gun sample name")
        particle = m.group(1)
        events = get_events_single_particles(particle)
    elif wildcards.sample.startswith("mg_"):
        m = re.match(r"mg_(\w+)", wildcards.sample)
        if m is None:
            raise ValueError("Cannot parse madgraph sample name")
        sample = m.group(1)
        events = get_events_madgraph(sample)
    else:
        raise ValueError("Cannot determine sample type for pileup event count")

    perc = 95 
    multiplier = poisson_percentile(perc, int(wildcards.pileup))
    print(f"{perc}% percentile for {wildcards.pileup} is {multiplier}, so generating {events*multiplier} soft QCD events")

    return events*multiplier


rule all:
  input:
    expand("reco/{sample}.edm4hep.root", sample=samples),
    expand("reco/plots/{sample}/{plot}.pdf", sample=samples, plot=finding_plots+fitting_plots),
    #expand("reco/plots/{sample}/plots_{sample}.pdf", sample=samples),
    #"gen/mg_ttbar.hepmc3.zst",
    #"gen/mg_dihiggs.hepmc3.zst",
    #expand("gen/{sample}.hepmc3.zst", sample=samples),
    #expand("sim/{sample}.edm4hep.root", sample=samples),
    #expand("digi/{sample}.edm4hep.root", sample=samples),
    #expand("reco/{sample}.edm4hep.root", sample=samples),



rule madgraph_init:
  output:
    "samples/mg_{sample}.tar.gz"
  input:
    "samples/{sample}.toml"
  # largely single thread but compilation goes up
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml -vv madgraph init {input} {output}"

rule madgraph_gen:
  input:
    "samples/{sample}.toml",
    "samples/mg_{sample}.tar.gz"
  output:
    "gen/mg_{sample}.hepmc3.zst",
    "gen/mg_{sample}.hepmc3.zst.json"
  params:
    events=get_events
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml -vv madgraph generate {input} --events {params.events} {output[0]}"

rule particle_gun:
  output:
    "gen/pg_{particle, [a-z]+}_pt{pt,\\d+}.hepmc3.zst",
    "gen/pg_{particle, [a-z]+}_pt{pt,\\d+}.hepmc3.zst.json"
  params:
    events=get_events
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml particle-gun --jobs {threads} {output[0]} --type {wildcards.particle} --pt {wildcards.pt} --events {params.events}"

rule pileup_gen:
  output:
    "gen/pu_{sample}_pu{pileup}.hepmc3.zst",
    "gen/pu_{sample}_pu{pileup}.hepmc3.zst.json",
  input:
    "samples/soft_qcd.toml"
  params:
    events=get_events_pileup
  shell:
    "./with_env.sh colliderml -vv pythia8 {input} {output[0]} --events {params.events}"

rule hepmc_smear:
  input:
    "gen/{sample}.hepmc3.zst",
    "gen/{sample}.hepmc3.zst.json",
    "pileup.toml",
  output:
    "gen/smeared/{sample}.hepmc3.zst",
    "gen/smeared/{sample}.hepmc3.zst.json",
  shell:
    "./with_env.sh colliderml -vv hepmc merge --hard-scatter {input[0]} --config {input[2]} {output[0]}"

rule hepmc_smear_merge:
  input:
    "gen/{sample}.hepmc3.zst",
    "gen/{sample}.hepmc3.zst.json",
    "gen/pu_{sample}_pu{pileup}.hepmc3.zst",
    "gen/pu_{sample}_pu{pileup}.hepmc3.zst.json",
    "pileup.toml",
  output:
    "gen/smeared/{sample}_pu{pileup}.hepmc3.zst",
    "gen/smeared/{sample}_pu{pileup}.hepmc3.zst.json",
  shell:
    "./with_env.sh colliderml -vv hepmc merge --hard-scatter {input[0]} --pileup {input[2]} --npileup {wildcards.pileup} --config {input[4]} {output[0]}"

def get_sim_inputs(wildcards):
    if wildcards.pileup == '0':
      # no pileup case means we don't need pileup, but we need to still produce smeared inputs
      return [
        f"gen/smeared/{wildcards.sample}.hepmc3.zst",
        f"gen/smeared/{wildcards.sample}.hepmc3.zst.json",
      ]
    else:
      # we need to schedule pileup generation + smearing & merging
      return [
        f"gen/smeared/{wildcards.sample}_pu{wildcards.pileup}.hepmc3.zst",
        f"gen/smeared/{wildcards.sample}_pu{wildcards.pileup}.hepmc3.zst.json",
      ]

    raise ValueError("Cannot determine sim inputs")

rule sim:
  input:
    get_sim_inputs,
    config_file,
  output:
    "sim/{sample}_pu{pileup}.edm4hep.root"
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml -vv simulation {input[0]} --output {output[0]} --processes {threads} --config {input[2]}"

rule digi:
  input:
    "sim/{sample}.edm4hep.root",
    config_file,
  output:
    "digi/{sample}.edm4hep.root"
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml digitization {input[0]} {output[0]} --jobs {threads} --config {input[1]}"

rule reco:
  input:
    "digi/{sample}.edm4hep.root",
    config_file,
  output:
    "reco/{sample}.edm4hep.root",
    "reco/performance_finding_ckf_{sample}.root",
    "reco/performance_fitting_ckf_{sample}.root"
  threads: workflow.cores
  shell:
    "./with_env.sh colliderml reconstruction {input[0]} {output[0]} --jobs {threads} --loglevel INFO --config {input[1]}"

rule reco_plots:
  input:
    "reco/performance_finding_ckf_{sample}.root",
    "reco/performance_fitting_ckf_{sample}.root"
  output:
    [f"reco/plots/{{sample}}/{plot}.pdf" for plot in finding_plots+fitting_plots],
    "reco/plots/{sample}/plots_{sample}.pdf"
  params:
    finding_plots = ','.join(finding_plots),
    fitting_plots = ','.join(fitting_plots)
  shell:
    "./with_env.sh colliderml plot reco {input} reco/plots/{wildcards.sample} --finding-plots {params.finding_plots} --fitting-plots {params.fitting_plots} --label {wildcards.sample}"
